/*
 * SpanningTreeHelp.java
 *
 * Created on 22 Dec 2013, 21.19
 */
package org.cytoscape.spanningtree.internal;

/**
 *
 * @author smd.faizan@gmail.com
 */
public class SpanningTreeHelp extends javax.swing.JFrame {

    private String helpString;

    /**
     * Creates new form SpanningTreeHelp
     */
    public SpanningTreeHelp() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        setForeground(new java.awt.Color(255, 255, 51));
        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane1.setViewportView(jTextArea1);
        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
                layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING).add(layout.createSequentialGroup().addContainerGap().add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 518, Short.MAX_VALUE).addContainerGap()));
        layout.setVerticalGroup(
                layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING).add(layout.createSequentialGroup().addContainerGap().add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 520, Short.MAX_VALUE).addContainerGap()));
        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {

            public void run() {
                new SpanningTreeHelp().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea jTextArea1;
    // End of variables declaration//GEN-END:variables

    public void setText(int buttonNumber) {
      
        helpString =
                "Tree: \n\n"
                + "Tree is a minimally connected graph. Specifically in graph theory,\n"
                + "a tree is an undirected graph in which any two vertices are connected\n"
                + "by exactly one simple path. In other words, any connected graph without\n"
                + "simple cycles is a tree.\n\n"
                + "Spanning Tree :\n\n\n"
                + "Given a graphA which is not a tree, we can make graphA a tree by eliminating\n"
                + "Given a connected graph, which is not a tree, one can extract(subgraph)a\n"
                + "tree out of the given graph by eliminating some edges(cyclic edges)\n"
                + "A spanning tree has (V-1) edges where V is the number of vertices in the given graph. "
                + "Extracting a spanning tree gets interesting when given graph is a weighted graph."
                + " In finding minimal/maximal spanning tree, one would ideally extract the tree whose "
                + "sum of weights is minimum/maximum. The weight of a spanning tree is the sum of weights"
                + " given to each edge of the spanning tree. "
                + "There may be several minimum spanning trees of the same weight having a minimum number of edges; in particular, "
                + "if all the edge weights of a given graph are the same, "
                + "then every spanning tree of that graph is minimum. "
                + "If each edge has a distinct weight then there will be only one, unique minimum spanning tree. \n\n" ;
                

        this.setTitle("Spanning Tree Help : ");
        
        jTextArea1.setText(helpString);
        jTextArea1.setCaretPosition(0);
    }
}
